{"name":"Shredder-instagram-challenge","body":"### Shredder-Instagram-Challenge\r\nMy take on the Instagram Challenge not really wanting a job, just wanted to test my py foo.\r\n\r\n### Technical Details\r\n[Link to original article here](http://instagram-engineering.tumblr.com/post/12651721845/instagram-engineering-challenge-the-unshredder)\r\n\r\n#### Instagram Engineering Challenge: The Unshredder\r\n\r\n![Shredder](http://media.tumblr.com/tumblr_luifuzcjzz1qm4rc3.png)\r\n\r\n#### THE CHALLENGE\r\n\r\nYour challenge, if you choose to accept it, is to write a simple script that takes a shredded image in as input:\r\n\r\n![Initial Image](http://media.tumblr.com/tumblr_luigsoCv3s1qm4rc3.png)\r\n\r\nand outputs an unshredded and reconstituted image. That is, imagine if you took an image, divided it into an even number of columns and shuffled those columns randomly to produce a shredded image. Then, take that image into the script and output the original image:\r\n\r\n![Final Image](http://media.tumblr.com/tumblr_luih7og6QM1qm4rc3.png)\r\n\r\nWe tackled this, and our solution took a few hours plus another few hours for the bonus challenge (more on that later).\r\n\r\n#### THE REWARD\r\n\r\nDue to overwhelming response, we’ve run out of our entire stock of tee-shirts! With future challenges we’ll be offering a reward for the first group of people who respond.\r\n\r\n#### GUIDELINES\r\n\r\n1) Choose a scripting language of your choice. We chose Python for its relative ease prototyping and availability of the Python Imaging Library (PIL) that allowed us to do the image stuff we wanted to do. You can easily use something like C++ or Ruby for this as well.\r\n\r\n2) Produce a script that reads in a shredded image (like the one below) and produces the original image. For this image, you can assume shreds are 32 pixels wide and uniformly spaced across the image horizontally. These shreds are scattered at random and if rearranged, will yield the original image.\r\n\r\nUse this image as the source image - it’s 640 pixels wide and 359 pixels high.\r\n\r\n3) Your solution should algorithmically unshred the image. This means it should work on arbitrarily shredded images we feed your script that are shredded in the same manner.\r\n\r\n4) BONUS CHALLENGE: We went the extra mile and made our script even spiffier by auto-detecting how wide the uniform strips are. Extra bonus points to anyone who works this into their solution. But first, we’d recommend getting your script to work assuming 32 pixel-wide shreds. For this you can assume shreds will never end up next to each other correctly in the source image.\r\n\r\n5) The key to this problem is being able to access pixel data in the image. We used Python Imaging Library - PIL (http://www.pythonware.com/products/pil/) which made it very easy to parse. See the PIL tips below. If you’re using Ruby, check out RMagick (http://rmagick.rubyforge.org/) which is a gem that serves the same purpose as PIL. C++ has the boost libraries and included is “GIL” which will help you. If you’re using another language, there are most certainly equivalents of PIL, RMagick, and GIL.\r\n\r\n#### SUBMIT YOUR SOLUTION\r\n\r\nWe’re no longer offering the tee-shirt reward but if you’re still interested in working with us, please submit your information & a link to your solution here: http://bit.ly/unshredder\r\n\r\n#### PIL TIPS\r\n\r\n```python\r\nfrom PIL import Image\r\nimage = Image.open(‘file.jpg’)\r\ndata = image.getdata() # This gets pixel data\r\n\r\n# Access an arbitrary pixel. Data is stored as a 2d array where rows are\r\n# sequential. Each element in the array is a RGBA tuple (red, green, blue,\r\n# alpha).\r\n\r\nx, y = 20, 90\r\ndef get_pixel_value(x, y):\r\n   width, height = image.size\r\n   pixel = data[y * width + x]\r\n   return pixel\r\nprint get_pixel_value(20, 30)\r\n\r\n# Create a new image of the same size as the original\r\n# and copy a region into the new image\r\nNUMBER_OF_COLUMNS = 5\r\nunshredded = Image.new(“RGBA”, image.size)\r\nshred_width = unshredded.size[0]/NUMBER_OF_COLUMNS\r\nshred_number = 1\r\nx1, y1 = shred_width * shred_number, 0\r\nx2, y2 = x1 + shred_width, height\r\nsource_region = image.crop(x1, y1, x2, y2)\r\ndestination_point = (0, 0)\r\nunshredded.paste(source_region, destination_point)\r\n# Output the new image\r\nunshredded.save(“unshredded.jpg”, “JPEG”)\r\n```\r\n\r\n#### TIPS\r\n\r\n1) Don’t overthink it. Use of really complex algorithms isn’t needed. Our solution WITH the bonus exercise comes in at just over 150 lines of python.\r\n\r\n2) Think about how you would quantify whether or not two shreds ‘fit’ together by using pixel data\r\n\r\n3) Assume you’re using the source image, or other normal photographs without edge-case patterns.\r\n\r\n4) There are edge cases where the script we wrote with our approach will not work because of repeating patterns. This is OK in your script as well. Don’t worry about special cases – focus on making the sample images work that we’ve provided.\r\n\r\n4) Bonus Challenge: If you decide you want to auto-detect how many columns there are in an image, you should remember that there are a finite amount of columns that are possible given an image of a certain width if you assume columns are evenly distributed and uniformly sized.\r\n\r\n#### SHREDDER\r\n\r\nIf you’d like to produce your own sample images, you can use our simple script here to generate some:\r\n\r\n```python\r\nfrom PIL import Image\r\nfrom random import shuffle\r\n\r\nSHREDS = 10\r\nimage = Image.open(“sample.png”)\r\nshredded = Image.new(“RGBA”, image.size)\r\nwidth, height = image.size\r\nshred_width = width/SHREDS\r\nsequence = range(0, SHREDS)\r\nshuffle(sequence)\r\n\r\nfor i, shred_index in enumerate(sequence):\r\n    shred_x1, shred_y1 = shred_width * shred_index, 0\r\n    shred_x2, shred_y2 = shred_x1 + shred_width, height\r\n    region =image.crop((shred_x1, shred_y1, shred_x2, shred_y2))\r\n    shredded.paste(region, (shred_width * i, 0))\r\n\r\nshredded.save(“sample_shredded.png”)\r\n```","google":"UA-37040692-1","tagline":"","note":"Don't delete this file! It's used internally to help with page regeneration."}